# Improving build of I18N files

Date: 2022-03-28

Deciders: Abban Dunne, Corinna Hillebrand, Gabriel Birke

## Status

Accepted

## Context and Problem Statement

The I18N files for the Fundraising Application are in a separate
repository that's deployed automatically. This allows us to deploy content
changes as soon as someone makes them, without developer intervention and
independently from feature changes. The current mechanism of integrating
the I18N strings with the JavaScript code is not efficient. This document
outlines the status quo and plans for improvement.

### Current delivery mechanism

Currently, we render *all* I18N strings as a JSON object in a HTML5
`data-` attribute in the application shell generated by the PHP backend.
The JavaScript code reads and decodes the attribute value. This has the
following drawbacks:

- The application shell (plain markup) is slow to load, consuming
	bandwidth for page changes.
- The PHP backend reads and outputs the I18N file on every request.
- We're delivering more I18N keys than needed. We're already taking steps
	to split the I18N strings into page-specific files (https://phabricator.wikimedia.org/T302203)
- The delivery mechanism blocks the evolution of the Fundraising to
	a Single-Page-Application + API architecture (see [ADR 21](021_Single_or_Multi_Page_Application_Architecture.md))


## Decision Drivers

- We want to keep the benefits (ease and immediacy of deployment) of the separation of
	frontend (code) and I18N (content) repositories. 
- We want to improve loading times (number of requests and file size) for the users. 
    If we have to make tradeoffs, we prefer smaller file sizes, since HTTP2 can reduce the impact of the number of requests.
- We want to evolve the application architecture to a 
	Single-Page-Application + API (see [ADR 21](021_Single_or_Multi_Page_Application_Architecture.md))
- We still want to have multiple languages and a language switcher
- Developer/Translator experience: It should be easy to find the
	translation key for an item on the page.

## Considered Options

- Load single-file JSON from server
- Load page-specific JSON from server
- Compile frontend with different language bundles 

## Decision Outcome

The considered options are not mutually exclusive, but build upon each
other, each stage optimizing a different aspect of our decision drivers.
We will evolve the code base until we have reached the 2nd stage Load
page-specific JSON from server), then re-evaluate if we want to implement
the 3rd stage (Compiled frontend bundles).

## Pros and Cons of the Options 

### Load single-file JSON from server

This changes the transport mechanism from "JSON-as-HTTP-attribute" to
"HTTP request when JavaScript has loaded". 

The drawback is one more blocking HTTP request. We can mitigate that
impact in two ways:

- by using HTTP2, which will multiplex the different requests and compress the header.
- by loading the strings into a global JavaScript variable (instead of JSON), with a 
   separate `<script>` tag in the header of the application shell, before
   loading the application JavaScript.

The benefits are

- enables the SPL+API architecture 
- reduces the transmitted file size (because the I18N strings are no longer double-encoded).
- Saves memory and CPU cycles on the server because we don't pass the content through
	the PHP interpreter and output buffer.

We will probably skip this step, since splitting the single translation
file into multiple ones has the additional benefit of easier translation
changes in the translation repository

### Load page-specific JSON from server 

The drawback is one more blocking HTTP request (two requests, if we have a "shared" JSON), which we can mitigate by using HTTP2.

The benefits are

- enables the SPL+API architecture
- reduces the transmitted file size (because the I18N strings are no longer double-encoded).
- reduces the file size even more by delivering only what's needed 
- potential for reducing the file size even further, by removing the page prefixes from the translation keys, making them shorter.
- Saves memory and CPU cycles on the server because we don't pass the content through
	the PHP interpreter and output buffer.

### Compile frontend with different language bundles

We create a mechanism to associate a branch in the I18N repository with a
branch in the frontend code repository and build and deploy the
application when the I18N code changes. We need this mechanism to have our
"develop - acceptance testing - deploy" cycle where the code deployed in
production is not the latest version.

Drawbacks

- Longer deploy times, since we build the whole application on content
	changes. Text changes will take 5-10 minutes instead of 1 minute to
	appear on the page.
- Effort to develop the CI mechanisms for associating I18N and content
	branches. Slight risk of prematurely deploying unfinished/unapproved
	features
- Bigger bundles, more bandwidth needed when switching languages

Benefits

- Better developer experience through tighter integration of code and
	content (using I18N as a dependency).
- Fewer HTTP requests.


